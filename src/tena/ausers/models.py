"""
`ausers` models for tena project.

Generated by 'python3 manage.py startapp' using Django 3.1.7.
 * NAME: Wendirad Demelash
 * DATE: April 3, 2021
"""
import json

from django.contrib import auth
from django.contrib.auth.models import Group, Permission, AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.contrib.auth.validators import UnicodeUsernameValidator
from django.core.validators import MinLengthValidator, RegexValidator
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from smart_selects.db_fields import ChainedForeignKey

class UserManager(BaseUserManager):
    def _create_user(self, password, **extra_fields):
        """
        Create and save a user with the given password.
        """
        user = self.model(**extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_user(self, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', False)
        extra_fields.setdefault('is_superuser', False)
        return self._create_user(password, **extra_fields)

    def create_superuser(self, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)

        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')

        return self._create_user(password, **extra_fields)

    def with_perm(self, perm, is_active=True, include_superusers=True, backend=None, obj=None):
        if backend is None:
            backends = auth._get_backends(return_tuples=True)
            if len(backends) == 1:
                backend, _ = backends[0]
            else:
                raise ValueError(
                    'You have multiple authentication backends configured and '
                    'therefore must provide the `backend` argument.'
                )
        elif not isinstance(backend, str):
            raise TypeError(
                'backend must be a dotted import path string (got %r).'
                % backend
            )
        else:
            backend = auth.load_backend(backend)
        if hasattr(backend, 'with_perm'):
            return backend.with_perm(
                perm,
                is_active=is_active,
                include_superusers=include_superusers,
                obj=obj,
            )
        return self.none()

class AbstractUser(AbstractBaseUser, PermissionsMixin):
    """ Custom User Model with to generalizer all users of platform. """
    SEX = (
        ('M', _('Male')),
        ('F', _('Female'))
    )
    first_name = models.CharField(_('first name'), max_length=150)
    last_name = models.CharField(_('last name'), max_length=150)
    sex = models.CharField(_('Sex'), max_length=2, choices=SEX)
    is_staff = models.BooleanField(
        _('staff status'),
        default=False,
        help_text=_('Designates whether the user can log into this admin site.'),
    )
    is_active = models.BooleanField(
        _('active'),
        default=True,
        help_text=_(
            'Designates whether this user should be treated as active. '
            'Unselect this instead of deleting accounts.'
        ),
    )
    date_joined = models.DateTimeField(_('date joined'), default=timezone.now)

    objects = UserManager()
    REQUIRED_FIELDS = []

    class Meta:
            abstract = True

    def get_full_name(self):
        """
        Return the first_name plus the last_name, with a space in between.
        """
        full_name = '%s %s' % (self.first_name, self.last_name)
        return full_name.strip()

    def get_short_name(self):
        """Return the short name for the user."""
        return self.first_name

class DefaultUser(AbstractUser):
    """ This class represent users beside customers """
    username_validator = UnicodeUsernameValidator()

    username = models.CharField(
        _('username'),
        max_length=150,
        unique=True,
        help_text=_('Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.'),
        validators=[username_validator],
        error_messages={
            'unique': _("A user with that username already exists."),
        },
    )
    USERNAME_FIELD = 'username'

    class Meta:
        verbose_name = _('user')

class Region(models.Model):
    name = models.CharField(_('Name'), max_length=255)

    def __str__(self):
        return self.name

class Zone(models.Model):
    region = models.ForeignKey(Region, verbose_name=_('Region'), on_delete=models.CASCADE)
    name = models.CharField(_('Name'), max_length=255)

    def __str__(self):
        return f'{self.name} | {self.region.name}'

class Woreda(models.Model):
    region = models.ForeignKey(Region, verbose_name=_('Region'), on_delete=models.CASCADE)
    zone = ChainedForeignKey(
            Zone,
            verbose_name=_('Zone'),
            chained_field='region',
            chained_model_field='region',
            show_all=False,
        )
    name = models.CharField(max_length=255)

    def __str__(self):
        return f'{self.name} | {self.region.name}'

class Address(models.Model):
    """ Implement common address attributes
            - Region
            - Zone
            - Woreda
            - House Number
    """
    region = models.ForeignKey(Region, verbose_name=_('Region'), on_delete=models.SET_NULL, null=True)
    zone = ChainedForeignKey(
            Zone,
            verbose_name=_('Zone'),
            chained_field='region',
            chained_model_field='region',
            show_all=False,
        )
    woreda = ChainedForeignKey(
            Woreda,
            verbose_name=_('Woreda'),
            chained_field='zone',
            chained_model_field='zone',
            show_all=False,
        )
    house_number = models.CharField(_('House number'), max_length=6)

    class Meta:
        abstract = True

class Customer(AbstractUser, Address):
    phone_regex = RegexValidator(
        r'(\+2519|09)\d{8}$',
        message='Please enter your phone number in +2519********'
                ' or 09******** format.'
    )
    phone_number = models.CharField(
            _('Phone number'),
            max_length=13,
            validators=[phone_regex],
            primary_key=True,
            help_text=_('Use to verify and notify user.')
        )
    is_verified = models.BooleanField(
            default=False,
            help_text=_('Identify wether user is verified or not.')
        )
    groups = models.ManyToManyField(
        Group,
        verbose_name=_('groups'),
        blank=True,
        help_text=_(
            'The groups this user belongs to. A user will get all permissions '
            'granted to each of their groups.'
        ),
        related_name="customers",
        related_query_name="customer"
    )
    user_permissions = models.ManyToManyField(
        Permission,
        verbose_name=_('user permissions'),
        blank=True,
        help_text=_('Specific permissions for this user.'),
        related_name="customers",
        related_query_name="customer"
    )
    USERNAME_FIELD = 'phone_number'

    class Meta:
        verbose_name = _('customer')

    def __str__(self):
        return self.get_short_name()
